
#ifndef PCYNLITX
#define PCYNLITX

#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <synchronizer_mpi.hpp>
#include <synchronizer.hpp>
#include <channel.hpp>
#include <chrono> 
#include <windows.h>
#include <type_traits>
#include <typeinfo>


namespace pcynlitx {

  class artificial
  {
      public:
      artificial(){};

  };

  template <typename T=artificial, typename M=artificial>
  class threads
  {
     public:

      explicit threads(int thr_num): syn(thr_num){

         this->syn.Receive_Main_Thread_Id(std::this_thread::get_id());

         this->connection_counter = 0;

         this->total_thread_number = thr_num; 

         this->operational_thread_number = thr_num;

         this->syn.Receive_Operational_Thread_Number(&this->operational_thread_number);
      };

      explicit threads(int thr_num, channel<M> * ch): syn(thr_num){

         this->syn.Receive_Main_Thread_Id(std::this_thread::get_id());

         this->connection_counter = 0;

         this->total_thread_number = thr_num; 

         this->operational_thread_number = thr_num;

         this->syn.Receive_Operational_Thread_Number(&this->operational_thread_number);

         this->syn_mpi.Receive_Synchronizer(&this->syn);

         this->syn_mpi.Receive_Messenger(ch);
      };

      explicit threads(T * ptr, int thr_num) : syn(thr_num){

        this->objPtr=ptr;

        this->syn.Receive_Main_Thread_Id(std::this_thread::get_id());

        this->connection_counter = 0;

        this->total_thread_number = thr_num; 

        this->operational_thread_number = thr_num;

        this->syn.Receive_Operational_Thread_Number(&this->operational_thread_number);
      };


      explicit threads(T * ptr, int thr_num, channel<M> * ch) : syn(thr_num){

        this->objPtr=ptr;

        this->syn_mpi.Receive_Messenger(ch);

        this->syn.Receive_Main_Thread_Id(std::this_thread::get_id());

        this->connection_counter = 0;

        this->total_thread_number = thr_num; 

        this->operational_thread_number = thr_num;

        this->syn.Receive_Operational_Thread_Number(&this->operational_thread_number);

        this->syn_mpi.Receive_Synchronizer(&this->syn);

      };


      virtual ~threads(){

           size_t thread_num = this->threadPool.size();

           for(size_t i=0;i<thread_num;i++){

               delete this->threadPool.at(i);
           }
      }

      T * objPtr;
      

      template<typename B, typename... args>
      B activate(B (T::* fPtr)  (synchronizer_mpi<M> & syn, args... thParams), 
      
        int thread_num, args... thParams){

        std::thread * th = new std::thread(fPtr,this->objPtr,std::ref(this->syn_mpi),thParams...);

        std::thread::id th_id = th->get_id();

        this->syn.Receive_Thread_ID(thread_num,th_id);

        this->connection_counter++;

        this->threadPool.push_back(th);

        this->threadPool.shrink_to_fit();

        if(this->connection_counter>=this->syn.GetTotalThreadNumber()){

           this->syn.connect_condition = true;

           while(!this->syn.connection_status){
            
                 Sleep(0.1);                        
           };

           this->syn.connection_wait();
         }  
      }


      template<typename B, typename... args>
      B activate(B (* func_Ptr) (synchronizer_mpi<M> & syn, args... thParams),  
      
        int thread_num, args... thParams){

        std::thread * th = new std::thread(func_Ptr,std::ref(this->syn_mpi),thParams...);
      
        std::thread::id th_id = th->get_id();

        this->syn_mpi.Receive_Thread_ID(thread_num,th_id);

        this->connection_counter++;

        this->threadPool.push_back(th);

        if(this->connection_counter>=this->syn.GetTotalThreadNumber()){

           this->syn.connect_condition = true;

           while(!this->syn.connection_status){
            
                 Sleep(0.1);                        
           };

           this->syn.connection_wait();
        }
      }

      

      template<typename B, typename... args>
      B activate(B (T::* fPtr)  (synchronizer & syn, args... thParams), 
      
        int thread_num, args... thParams){

        std::thread * th = new std::thread(fPtr,this->objPtr,std::ref(this->syn),thParams...);

        std::thread::id th_id = th->get_id();

        this->syn.Receive_Thread_ID(thread_num,th_id);

        this->connection_counter++;

        this->threadPool.push_back(th);

        this->threadPool.shrink_to_fit();

        if(this->connection_counter>=this->syn.GetTotalThreadNumber()){

           this->syn.connect_condition = true;

           while(!this->syn.connection_status){
            
                 Sleep(0.1);                        
           };

           this->syn.connection_wait();
         }  
      }


      template<typename B, typename... args>
      B activate(B (* func_Ptr) (synchronizer & syn, args... thParams),  
      
        int thread_num, args... thParams){

        std::thread * th = new std::thread(func_Ptr,std::ref(this->syn),thParams...);
      
        std::thread::id th_id = th->get_id();

        this->syn.Receive_Thread_ID(thread_num,th_id);

        this->connection_counter++;

        this->threadPool.push_back(th);

        if(this->connection_counter>=this->syn.GetTotalThreadNumber()){

           this->syn.connect_condition = true;

           while(!this->syn.connection_status){
            
                 Sleep(0.1);                        
           };

           this->syn.connection_wait();
        }
      }


      void join(int thrNum){

           this->threadPool.at(thrNum)->join();

           this->syn.Exit(thrNum);            
      }

      synchronizer_mpi<M> syn_mpi;

      synchronizer syn;

      channel<M> * ch;

     protected:

      std::vector<std::thread *> threadPool;

      int connection_counter;

      int total_thread_number;

      int operational_thread_number;

      std::mutex mtx;

   };
};


#endif  /* PCYNLITX */